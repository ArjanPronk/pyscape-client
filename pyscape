#!/usr/bin/python3

import argparse
import sys
import json
import csv

from src.pyscape import Pyscape
from src.queries import *
from src.cli import *

def load_scope(preset):
    "Find the scope for the API call user has selected"

    with open('./data/defaults.json', 'r') as f:
        data = json.load(f)
    
    return data[preset]['scope']
    
def load_sort(preset):
    "Find an appropriate sort for the API call user has selected."

    with open('./data/defaults.json', 'r') as f:
        data = json.load(f)
    
    return data[preset]['sort']

def load_cols(preset, c_id):
    "Get the return fields the user's selection requires"

    with open('./data/defaults.json', 'r') as f:
        data = json.load(f)

    with open('./data/bitflags.json', 'r') as g:
        index = json.load(g)

    cols = 0

    for i in data[preset][c_id]:
        # The bitflag.json generating script returns strings? 
        # Because the bitflag.json generator doesn't filter properly...
        cols = cols | int(index[i]['flag'])

    return cols

def do_anchor(pys, args):
    "If the user wants anchor text, figure out the right preset"
    
    url = args.source

    preset = 'a_'

    if args.phrase:
        preset += 'pt'
    elif args.term:
        preset += 'tt'
    
    if args.domain_mode:
        preset += 'd'
    elif args.subdomain_mode:
        preset += 's'
    elif args.page_mode:
        preset += 'p'

    cols = load_cols(preset, 'c')
    scope = load_scope(preset)

    params = (cols, scope)
    
    return (preset, a_query(pys, url, *params))

def do_bulk_metrics(pys, args):
    "If the user wants bulk metrics, figure out the right preset and run"
    
    urls = []
    
    with open(args.source, 'r') as f:
        for line in f:
            urls.append(line.rstrip())
    
    if args.domain_mode:
        preset = 'u_d'
    elif args.subdomain_mode:
        preset = 'u_s'
    elif args.page_mode:
        preset = 'u_p'

    cols = load_cols(preset, 'c')

    return (preset, bulk_metrics(pys, urls, cols))

def do_links(pys, args):
    "If the user wants a link list, figure out the right preset and run"

    url = args.source

    preset = 'l_'

    if args.one_page:
        preset += 'dt'
    elif args.many_pages:
        preset += 'pt'

    if args.domain_mode:
        preset += 'd'
    elif args.subdomain_mode:
        preset += 's'
    elif args.page_mode:
        preset += 'p'

    tc = load_cols(preset, 'tc')
    sc = load_cols(preset, 'sc')
    lc = load_cols(preset, 'lc')
    scope = load_scope(preset)
    sort = load_sort(preset)

    params = (tc, sc, lc, scope, sort)

    return (preset, l_query(pys, url, *params))

def do_metrics(pys, args):
    "if the user wants basic metrics, find preset and run"

    url = args.source

    if args.domain_mode:
        preset = 'u_d'
    elif args.subdomain_mode:
        preset = 'u_s'
    elif args.page_mode:
        preset = 'u_p'

    cols = load_cols(preset, 'c')

    return (preset, u_query(pys, url, cols))

def do_top(pys, args):
    "if top pages, find preset and run"
    
    url = args.source

    preset = 't'

    cols = load_cols(preset, 'c')

    return (preset, t_query(pys, url, cols))

def do_json(args, data):
    "generate json output"

    with open(args.dest, 'w') as f:
        f.write(str(data).replace('\'', '\"'))

def do_csv(args, preset, data):
    "generate csv output"

    with open('./data/defaults.json', 'r') as f:
        defaults = json.load(f)

    with open('./data/bitflags.json', 'r') as g:
        index = json.load(g)

    output = []
    headers = []
    keys = []
    col_types = ['c', 'tc', 'sc', 'lc']

    # Generate human-readable headers from our index
    for i in col_types:
        # Some col_types will always be missing...
        # is there a better way to deal with this?
        try:    
            for j in defaults[preset][i]:
                keys.append(j)
                headers.append(index[j]['human'])
        except:
            pass

    output.append(headers)

    # Read appropriate columns from data
    for record in data:
        line = []
        for k in keys:
            line.append(record[k])
        output.append(line)

    with open(args.dest, 'w') as outfile:
        writer = csv.writer(outfile, delimiter = ',',
                            quotechar = '"',
                            dialect = 'excel',
                            quoting = csv.QUOTE_ALL)
        writer.writerows(output)

def main():

    parser = build_parser()
    args = parser.parse_args()

    # load API credentials
    with open('keys.json', 'r') as k:
        key_string = json.load(k)

    pys = Pyscape(key_string['access-id'], key_string['secret-key'])

    # interpret user's input
    if args.command == 'metrics':
        output = do_metrics(pys, args)
    elif args.command == 'top':
        output = do_top(pys, args)
    elif args.command == 'bulk-metrics':
        output = do_bulk_metrics(pys, args)
    elif args.command == 'links':
        output = do_links(pys, args)
    elif args.command == 'anchor':
        output = do_anchor(pys, args)

    # file writing functions need to know both the data and what
    # response fields were requested
    preset, data = output[0], output[1]

    # write output
    if args.json:
        do_json(args, data)
    elif args.csv:
        do_csv(args, preset, data)
   
    print('Job finished.')

if __name__ == '__main__':
    sys.exit(main())
